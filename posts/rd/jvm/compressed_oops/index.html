<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>ES为什么建议使用32或者26GB的堆？ | 宋惠龙的博客</title>
<meta name="keywords" content="指针压缩, compressed-oops, 研究一下, JVM调优, ES" />
<meta name="description" content="解答：ES为什么建议使用32或者26GB的堆？并且了解JVM中的指针压缩设计。">
<meta name="author" content="DragonSong">
<link rel="canonical" href="https://redolog.github.io/posts/rd/jvm/compressed_oops/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.381b1f6e3e5f48c6ea0614a03942519ee25190a2244a20e1a46cffb0b9f4499e.css" integrity="sha256-OBsfbj5fSMbqBhSgOUJRnuJRkKIkSiDhpGz/sLn0SZ4=" rel="preload stylesheet" as="style">
<link rel="preload" href="/favicons/favicon16.ico" as="image">
<link rel="icon" href="https://redolog.github.io/favicons/favicon16.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://redolog.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://redolog.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://redolog.github.io/favicons/favicon_apple_touch.ico">
<link rel="mask-icon" href="https://redolog.github.io/favicons/favicon_apple_touch.ico">
<meta name="theme-color" content="#fff2f2">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="ES为什么建议使用32或者26GB的堆？" />
<meta property="og:description" content="解答：ES为什么建议使用32或者26GB的堆？并且了解JVM中的指针压缩设计。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://redolog.github.io/posts/rd/jvm/compressed_oops/" /><meta property="og:image" content="https://redolog.github.io/avatar.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-29T21:01:25&#43;08:00" />
<meta property="article:modified_time" content="2021-12-29T21:01:25&#43;08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://redolog.github.io/avatar.png"/>

<meta name="twitter:title" content="ES为什么建议使用32或者26GB的堆？"/>
<meta name="twitter:description" content="解答：ES为什么建议使用32或者26GB的堆？并且了解JVM中的指针压缩设计。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://redolog.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "ES为什么建议使用32或者26GB的堆？",
      "item": "https://redolog.github.io/posts/rd/jvm/compressed_oops/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ES为什么建议使用32或者26GB的堆？",
  "name": "ES为什么建议使用32或者26GB的堆？",
  "description": "解答：ES为什么建议使用32或者26GB的堆？并且了解JVM中的指针压缩设计。\n",
  "keywords": [
    "指针压缩", "compressed-oops", "研究一下", "JVM调优", "ES"
  ],
  "articleBody": "解答：ES为什么建议使用32或者26GB的堆？并且了解JVM中的指针压缩设计。\n结论 Elasticsearch推荐使用的堆大小不超过32GB，主要是因为Java的垃圾收集器（Garbage Collector）和对象指针压缩（Compressed Object Pointers）的工作方式。\n对象指针压缩：在64位的JVM中，如果堆大小小于32GB，JVM可以使用一种叫做\"Compressed Ordinary Object Pointers\"（COOP）的技术，将64位的指针压缩为32位。这样可以节省大量的内存，因为在JVM中，大部分的内存都是用来存储对象指针的。但是，一旦堆大小超过32GB，JVM就不能使用COOP，这会导致内存使用率显著增加。 而推荐26GB堆的原因则是JVM内部内存计算并不是严格的1024进位，即1GB==1000MB，因此使用26GB可以确保使用到COOP技术。 垃圾收集器：Java的垃圾收集器在处理大堆时，可能会导致长时间的停顿。这是因为垃圾收集器需要遍历整个堆来查找和清理无用的对象。如果堆太大，这个过程可能会花费很长时间，导致Elasticsearch无法响应请求。 因此，Elasticsearch推荐的堆大小是物理内存的一半，最大不超过32GB。这样可以在保持对象指针压缩和避免长时间的垃圾收集停顿之间找到一个平衡。\n本文下方记录研究此问题的过程。\n前提 针对ES文档设置堆大小产生疑问。 我想了解下JVM中的指针压缩设计，也就是上述疑问的答案。 JVM自动帮开发者管理内存（开发者无需自行操作内存指针）。 指针压缩是JVM针对内存管理所做的优化技巧之一。 本文提到的JVM默认均为HotSpot JVM。\n本文使用到的JVM参数：\n1 2 3 4 5 6 7 8 # 打开指针压缩，jdk7之后只要 -Xmx 的值少于32GB在64位机器上都默认打开 -XX:-UseCompressedOops # 打印指针压缩日志 -XX:+PrintCompressedOopsMode # 指定对齐填充字节，默认对齐8字节 -XX:ObjectAlignmentInBytes=16 # 打开诊断JVM选项 -XX:+UnlockDiagnosticVMOptions JVM对象结构 我们先看看JVM中的对象在内存中是如何表示的：\n对象头（object header） mark word 存放了： 锁信息（biased locking pattern, locking information） hashCode（identity hashcode） GC信息（GC metadata） 指向类的指针（klass word） Java7之前指向的是永久代，从Java8开始指向元空间。 类名（class name） 修饰符（modifiers） 父类信息（superclass info） 数组长度（仅针对数组对象，4字节） 实例数据（instance data 或者 array data） 对象实际信息，比如字段值 对齐填充（alignment paddings） 占用32位4字节，对齐的设计是为了硬件友好。 同时在JVM中，使用Ordinary Object Pointers (OOPS)数据结构表示指向对象的指针。而指向对象与数组的指针的数据结构叫oopDesc。这个oopDesc包含了上面我们提到的两个内容：\nmark word klass word 这部分是可以被压缩的。 如下源码：\n1 2 3 4 5 6 7 8 9 class oopDesc { friend class VMStructs; private: volatile markOop _mark; union _metadata { Klass* _klass; narrowKlass _compressed_klass; } _metadata; } 以上，普通对象对应instanceOop，而数组对象对应arrayOop。\n32位机器到64位机器的变化 32位机器的一个限制：堆内存最大4GB。原因是内存只有2^32bit==2^10(KB)*2^10(MB)*2^10(GB)*4即4GB大小，OS级别也受此限制。而64位机器内存则高达TB级别。\n在64位机器上。 普通对象长度至少16字节，其中包括：\nmark word 8字节 klass word 4字节 padding对齐填充 4字节 数组对象长度至少16字节，其中包括：\nmark word 8字节 klass word 4字节 数组长度 4字节（32位的word） 当我们从32位机器迁移到64位机器上时，肯定是希望性能更好，但是这个问题没有这么简单。\n如上面的描述，我们的对象有指针（klass word），而指针在64位机器上占用了大约是32位机器上1.5倍的空间。同时也带来了新的问题：\n更多的内存消耗 更频繁的GC（导致我们的应用线程占用更少的CPU时间片） 所以这引出了JVM内存优化的方案：指针压缩。\n指针压缩 指针压缩即Compressed Oops，简称COOP。\nJVM默认帮我们开启了指针压缩，作用是在64位的机器上也可以存储32位的指针（对象头中的类型指针以及引用类型的字段），从而节省内存、提高性能。\n在实现上，压缩的是oopDesc中的_metadata。\n64位转32位：encode；32位转64位：decode。\nencode过程的原理我们可以这么理解：\n时间换空间（利用CPU计算少许逻辑，达到节省内存的作用），因为需要计算，所以叫做encode 由于JVM默认对齐填充8字节，所以我们的oops永远是8的倍数，而8的倍数使用二进制表示时，最后三位永远是0，所以我们多出来三位，decode时可以补三位零进行还原。 综上，64位机器上我们使用32位的空间，实际可以寻址到2^35bit==2^10(KB)*2^10(MB)*2^10(GB)*2^5==32GB。\n所以使用更少的空间，我们可以寻址更多地址。\n对应decode时，我们需要将其左移 3 位，再加上一个固定偏移量，便可以得到能够寻址 32GB 地址空间的伪 64 位指针了。\n基于0虚拟地址的指针压缩 Zero-Based Compressed Ordinary Object Pointers (oops) Zero-Based指针压缩的意思就是从32位decode64位地址时无需加一个Java堆的基础地址。\n当堆小于4GB时，JVM内可以使用一个字节的偏移量，避免使用一个对象的偏移量，这也就节省了一个8位的偏移量空间。同时将64位地址encode为32位地址时也非常高效。\n在Solaris, Linux, Windows这些系统上，堆空间小于26GB时，一般可以用到Zero-Based指针压缩（相比普通指针压缩更加高效）。\n小结 通过本文，我们从理论上研究了JVM指针压缩以及基于0虚拟地址的指针压缩设计原理。\n也明白了为什么ES建议JVM堆调优设置为32GB：使用指针压缩性能更好，而使用26GB时可以应用到基于0虚拟地址的指针压缩，性能更佳。\nRef anatomy-quarks/23-compressed-references Compressed OOPs in the JVM HotSpot/CompressedOops ES:ECE:JVM Heap Sizes elasticsearch:Setting the heap size javase/7/docs/technotes/guides/vm/performance-enhancements-7.html ",
  "wordCount" : "2459",
  "inLanguage": "en",
  "datePublished": "2021-12-29T21:01:25+08:00",
  "dateModified": "2021-12-29T21:01:25+08:00",
  "author":[{
    "@type": "Person",
    "name": "DragonSong"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://redolog.github.io/posts/rd/jvm/compressed_oops/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "宋惠龙的博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://redolog.github.io/favicons/favicon16.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-9EJ8N0FFCW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9EJ8N0FFCW');
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://redolog.github.io/" accesskey="h" title="宋惠龙的博客 (Alt + H)">
                <img src="https://redolog.github.io/favicons/favicon16.ico" alt="logo" aria-label="logo"
                    height="35">宋惠龙的博客</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://redolog.github.io/archives/" title="文章归档">
                    <span>文章归档</span>
                </a>
            </li>
            <li>
                <a href="https://redolog.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/redolog" title="GitHub">
                    <span><i class='fab fa-github fa-fw'></i></span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://redolog.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://redolog.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      ES为什么建议使用32或者26GB的堆？
    </h1>
    <div class="post-meta"><span title='2021-12-29 21:01:25 +0800 CST'>December 29, 2021</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;DragonSong

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e7%bb%93%e8%ae%ba" aria-label="结论">结论</a></li>
                    <li>
                        <a href="#%e5%89%8d%e6%8f%90" aria-label="前提">前提</a></li>
                    <li>
                        <a href="#jvm%e5%af%b9%e8%b1%a1%e7%bb%93%e6%9e%84" aria-label="JVM对象结构"><code>JVM</code>对象结构</a></li>
                    <li>
                        <a href="#32%e4%bd%8d%e6%9c%ba%e5%99%a8%e5%88%b064%e4%bd%8d%e6%9c%ba%e5%99%a8%e7%9a%84%e5%8f%98%e5%8c%96" aria-label="32位机器到64位机器的变化">32位机器到64位机器的变化</a></li>
                    <li>
                        <a href="#%e6%8c%87%e9%92%88%e5%8e%8b%e7%bc%a9" aria-label="指针压缩">指针压缩</a></li>
                    <li>
                        <a href="#%e5%9f%ba%e4%ba%8e0%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%9a%84%e6%8c%87%e9%92%88%e5%8e%8b%e7%bc%a9" aria-label="基于0虚拟地址的指针压缩">基于0虚拟地址的指针压缩</a></li>
                    <li>
                        <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a></li>
                    <li>
                        <a href="#ref" aria-label="Ref">Ref</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>解答：ES为什么建议使用32或者26GB的堆？并且了解<code>JVM</code>中的指针压缩设计。</p>
<h1 id="结论">结论<a hidden class="anchor" aria-hidden="true" href="#结论">#</a></h1>
<p><code>Elasticsearch</code>推荐使用的堆大小不超过32GB，主要是因为<code>Java</code>的垃圾收集器<code>（Garbage Collector）</code>和对象指针压缩<code>（Compressed Object Pointers）</code>的工作方式。</p>
<ul>
<li>对象指针压缩：在64位的<code>JVM</code>中，如果堆大小小于32GB，JVM可以使用一种叫做<code>&quot;Compressed Ordinary Object Pointers&quot;（COOP）</code>的技术，将64位的指针压缩为32位。这样可以节省大量的内存，因为在JVM中，大部分的内存都是用来存储对象指针的。但是，一旦堆大小超过32GB，JVM就不能使用COOP，这会导致内存使用率显著增加。</li>
<li>而推荐26GB堆的原因则是<code>JVM</code>内部内存计算并不是严格的1024进位，即1GB==1000MB，因此使用26GB可以确保使用到<code>COOP</code>技术。</li>
<li>垃圾收集器：Java的垃圾收集器在处理大堆时，可能会导致长时间的停顿。这是因为垃圾收集器需要遍历整个堆来查找和清理无用的对象。如果堆太大，这个过程可能会花费很长时间，导致Elasticsearch无法响应请求。</li>
</ul>
<p>因此，Elasticsearch推荐的堆大小是物理内存的一半，最大不超过32GB。这样可以在保持对象指针压缩和避免长时间的垃圾收集停顿之间找到一个平衡。</p>
<p>本文下方记录研究此问题的过程。</p>
<h1 id="前提">前提<a hidden class="anchor" aria-hidden="true" href="#前提">#</a></h1>
<ol>
<li>针对ES文档<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/heap-size.html">设置堆大小</a>产生疑问。</li>
<li>我想了解下<code>JVM</code>中的指针压缩设计，也就是上述疑问的答案。</li>
<li><code>JVM</code>自动帮开发者管理内存（开发者无需自行操作内存指针）。</li>
<li>指针压缩是<code>JVM</code>针对内存管理所做的优化技巧之一。</li>
</ol>
<p>本文提到的<code>JVM</code>默认均为<code>HotSpot JVM</code>。</p>
<p>本文使用到的<code>JVM</code>参数：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># 打开指针压缩，jdk7之后只要 -Xmx 的值少于32GB在64位机器上都默认打开</span>
</span></span><span style="display:flex;"><span>-XX:-UseCompressedOops 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 打印指针压缩日志</span>
</span></span><span style="display:flex;"><span>-XX:+PrintCompressedOopsMode
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 指定对齐填充字节，默认对齐8字节</span>
</span></span><span style="display:flex;"><span>-XX:ObjectAlignmentInBytes<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 打开诊断JVM选项</span>
</span></span><span style="display:flex;"><span>-XX:+UnlockDiagnosticVMOptions
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="jvm对象结构"><code>JVM</code>对象结构<a hidden class="anchor" aria-hidden="true" href="#jvm对象结构">#</a></h1>
<p>我们先看看<code>JVM</code>中的对象在内存中是如何表示的：</p>
<ol>
<li>对象头（object header）
<ol>
<li><a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/oop.hpp#L56">mark word</a>
存放了：
<ul>
<li>锁信息（biased locking pattern, locking information）</li>
<li>hashCode（identity hashcode）</li>
<li>GC信息（GC metadata）</li>
</ul>
</li>
<li>指向类的指针（<a href="https://github.com/openjdk/jdk15/blob/bf1e6903a2499d0c2ab2f8703a1dc29046e8375d/src/hotspot/share/oops/klass.hpp#L54">klass word</a>）
<code>Java7</code>之前指向的是<a href="https://www.baeldung.com/native-memory-tracking-in-jvm">永久代</a>，从<code>Java8</code>开始指向<a href="https://www.baeldung.com/native-memory-tracking-in-jvm">元空间</a>。
<ol>
<li>类名（class name）</li>
<li>修饰符（modifiers）</li>
<li>父类信息（superclass info）</li>
</ol>
</li>
<li>数组长度（仅针对数组对象，4字节）</li>
</ol>
</li>
<li>实例数据（instance data 或者 array data）
对象实际信息，比如字段值</li>
<li>对齐填充（alignment paddings）
占用32位4字节，对齐的设计是为了硬件友好。</li>
</ol>
<!-- （[uintptr_t](https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/markWord.hpp#L96) ）
    uintptr_t这个结构再32位机器上占用4字节，而在64位机器上占用8字节。 -->
<p>同时在<code>JVM</code>中，使用<code>Ordinary Object Pointers</code> (<a href="https://github.com/openjdk/jdk15/tree/master/src/hotspot/share/oops">OOPS</a>)数据结构表示指向对象的指针。而指向对象与数组的指针的数据结构叫<a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/oop.hpp#L52">oopDesc</a>。这个<code>oopDesc</code>包含了上面我们提到的两个内容：</p>
<ol>
<li><a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/oop.hpp#L56">mark word</a></li>
<li><a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/oop.hpp#L57">klass word</a>
这部分是可以被压缩的。</li>
</ol>
<p>如下源码：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">oopDesc</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">VMStructs</span>;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">volatile</span> markOop  _mark;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">_metadata</span> {
</span></span><span style="display:flex;"><span>    Klass<span style="color:#f92672">*</span>      _klass;
</span></span><span style="display:flex;"><span>    narrowKlass _compressed_klass;
</span></span><span style="display:flex;"><span>  } _metadata;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上，普通对象对应<a href="https://github.com/openjdk/jdk15/blob/master/src/hotspot/share/oops/instanceOop.hpp">instanceOop</a>，而数组对象对应<a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/arrayOop.hpp#L35">arrayOop</a>。</p>
<h1 id="32位机器到64位机器的变化">32位机器到64位机器的变化<a hidden class="anchor" aria-hidden="true" href="#32位机器到64位机器的变化">#</a></h1>
<p>32位机器的一个限制：堆内存最大4GB。原因是内存只有<code>2^32bit</code>==<code>2^10(KB)*2^10(MB)*2^10(GB)*4</code>即4GB大小，<code>OS</code>级别也受此限制。而64位机器内存则高达TB级别。</p>
<p>在64位机器上。
普通对象长度至少16字节，其中包括：</p>
<ul>
<li>mark word 8字节</li>
<li>klass word 4字节</li>
<li>padding对齐填充 4字节</li>
</ul>
<p>数组对象长度至少16字节，其中包括：</p>
<ul>
<li>mark word 8字节</li>
<li>klass word 4字节</li>
<li>数组长度 4字节（<a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/arrayOop.hpp#L35">32位的word</a>）</li>
</ul>
<p>当我们从32位机器迁移到64位机器上时，肯定是希望性能更好，但是这个问题没有这么简单。</p>
<p>如上面的描述，我们的对象有指针（<code>klass word</code>），而指针在64位机器上占用了大约是32位机器上1.5倍的空间。同时也带来了新的问题：</p>
<ul>
<li>更多的内存消耗</li>
<li>更频繁的<code>GC</code>（导致我们的应用线程占用更少的<code>CPU</code>时间片）</li>
</ul>
<p>所以这引出了<code>JVM</code>内存优化的方案：指针压缩。</p>
<h1 id="指针压缩">指针压缩<a hidden class="anchor" aria-hidden="true" href="#指针压缩">#</a></h1>
<p>指针压缩即<code>Compressed Oops</code>，简称<code>COOP</code>。</p>
<p><code>JVM</code>默认帮我们开启了指针压缩，作用是在64位的机器上也可以存储32位的指针（<strong>对象头中的类型指针以及引用类型的字段</strong>），从而节省内存、提高性能。</p>
<p>在实现上，压缩的是<code>oopDesc</code>中的<code>_metadata</code>。</p>
<p>64位转32位：<code>encode</code>；32位转64位：<code>decode</code>。</p>
<p><code>encode</code>过程的原理我们可以这么理解：</p>
<ol>
<li>时间换空间（利用CPU计算少许逻辑，达到节省内存的作用），因为需要计算，所以叫做<code>encode</code></li>
<li>由于<code>JVM</code>默认对齐填充8字节，所以我们的<code>oops</code>永远是8的倍数，而8的倍数使用二进制表示时，最后三位永远是0，所以我们多出来三位，<code>decode</code>时可以补三位零进行还原。</li>
</ol>
<p>综上，64位机器上我们使用32位的空间，实际可以寻址到<code>2^35bit</code>==<code>2^10(KB)*2^10(MB)*2^10(GB)*2^5</code>==32GB。</p>
<p>所以使用更少的空间，我们可以寻址更多地址。</p>
<p>对应<code>decode</code>时，我们需要将其左移 3 位，再加上一个固定偏移量，便可以得到能够寻址 32GB 地址空间的伪 64 位指针了。</p>
<h1 id="基于0虚拟地址的指针压缩">基于0虚拟地址的指针压缩<a hidden class="anchor" aria-hidden="true" href="#基于0虚拟地址的指针压缩">#</a></h1>
<p>Zero-Based Compressed Ordinary Object Pointers (oops)
Zero-Based指针压缩的意思就是从32位decode64位地址时<strong>无需</strong>加一个<code>Java</code>堆的基础地址。</p>
<p>当堆小于4GB时，<code>JVM</code>内可以使用一个字节的偏移量，避免使用一个对象的偏移量，这也就节省了一个8位的偏移量空间。同时将64位地址<code>encode</code>为32位地址时也非常高效。</p>
<p>在<code>Solaris</code>, <code>Linux</code>,  <code>Windows</code>这些系统上，堆空间小于26GB时，一般可以用到Zero-Based指针压缩（相比普通指针压缩更加高效）。</p>
<h1 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h1>
<p>通过本文，我们从理论上研究了<code>JVM</code>指针压缩以及基于0虚拟地址的指针压缩设计原理。</p>
<p>也明白了为什么ES建议<code>JVM</code>堆调优设置为32GB：使用指针压缩性能更好，而使用26GB时可以应用到基于0虚拟地址的指针压缩，性能更佳。</p>
<h1 id="ref">Ref<a hidden class="anchor" aria-hidden="true" href="#ref">#</a></h1>
<ul>
<li><a href="https://shipilev.net/jvm/anatomy-quarks/23-compressed-references/">anatomy-quarks/23-compressed-references</a></li>
<li><a href="https://www.baeldung.com/jvm-compressed-oops">Compressed OOPs in the JVM</a></li>
<li><a href="https://wiki.openjdk.java.net/display/HotSpot/CompressedOops">HotSpot/CompressedOops</a></li>
<li><a href="https://www.elastic.co/guide/en/cloud-enterprise/2.0/ece-heap.html">ES:ECE:JVM Heap Sizes</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/heap-size.html">elasticsearch:Setting the heap size</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a></li>
</ul>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://redolog.github.io/tags/%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9/">指针压缩</a></li>
      <li><a href="https://redolog.github.io/tags/compressed-oops/">compressed-oops</a></li>
      <li><a href="https://redolog.github.io/tags/%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B/">研究一下</a></li>
      <li><a href="https://redolog.github.io/tags/jvm%E8%B0%83%E4%BC%98/">JVM调优</a></li>
      <li><a href="https://redolog.github.io/tags/es/">ES</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://redolog.github.io/posts/rd/log/translation/what-every-software-engineer-should-know-about-real-time-datas-unifying/">
    <span class="title">« Prev Page</span>
    <br>
    <span>译---日志：每个软件工程师都应该知道的有关实时数据的统一抽象</span>
  </a>
  <a class="next" href="https://redolog.github.io/posts/rd/troubleshoot/db-replicate-delay/apply_callback_miss/">
    <span class="title">Next Page »</span>
    <br>
    <span>MySQL主从延迟业务数据缺失问题一例</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share ES为什么建议使用32或者26GB的堆？ on twitter"
        href="https://twitter.com/intent/tweet/?text=ES%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a832%e6%88%96%e8%80%8526GB%e7%9a%84%e5%a0%86%ef%bc%9f&amp;url=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fjvm%2fcompressed_oops%2f&amp;hashtags=%e6%8c%87%e9%92%88%e5%8e%8b%e7%bc%a9%2ccompressed-oops%2c%e7%a0%94%e7%a9%b6%e4%b8%80%e4%b8%8b%2cJVM%e8%b0%83%e4%bc%98%2cES">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share ES为什么建议使用32或者26GB的堆？ on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fjvm%2fcompressed_oops%2f&amp;title=ES%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a832%e6%88%96%e8%80%8526GB%e7%9a%84%e5%a0%86%ef%bc%9f&amp;summary=ES%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a832%e6%88%96%e8%80%8526GB%e7%9a%84%e5%a0%86%ef%bc%9f&amp;source=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fjvm%2fcompressed_oops%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share ES为什么建议使用32或者26GB的堆？ on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fjvm%2fcompressed_oops%2f&title=ES%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a832%e6%88%96%e8%80%8526GB%e7%9a%84%e5%a0%86%ef%bc%9f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share ES为什么建议使用32或者26GB的堆？ on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fjvm%2fcompressed_oops%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share ES为什么建议使用32或者26GB的堆？ on whatsapp"
        href="https://api.whatsapp.com/send?text=ES%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a832%e6%88%96%e8%80%8526GB%e7%9a%84%e5%a0%86%ef%bc%9f%20-%20https%3a%2f%2fredolog.github.io%2fposts%2frd%2fjvm%2fcompressed_oops%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share ES为什么建议使用32或者26GB的堆？ on telegram"
        href="https://telegram.me/share/url?text=ES%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a832%e6%88%96%e8%80%8526GB%e7%9a%84%e5%a0%86%ef%bc%9f&amp;url=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fjvm%2fcompressed_oops%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
      const gitalk = new Gitalk({
            clientID: 'bc5a91c74dda1fd92a10',
            clientSecret: '99a821a1c27e5dc85ea3105bf9bba089d1b580ea',
            repo: 'blog-comment',
            owner: 'redolog',
            admin: ['redolog'],
            id: md5(location.pathname), 
            distractionFreeMode: false 
      });
      (function () {
            if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
                  document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
                  return;
            }
            gitalk.render('gitalk-container');
      })();
</script>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://redolog.github.io/">宋惠龙的博客</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
