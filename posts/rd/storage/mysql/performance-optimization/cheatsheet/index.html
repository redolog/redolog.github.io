<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MySQL性能优化cheatsheet | 宋惠龙的博客</title>
<meta name="keywords" content="MySQL, cheatsheet, index, 索引优化, 性能优化" />
<meta name="description" content="MySQL性能优化cheatsheet。">
<meta name="author" content="DragonSong">
<link rel="canonical" href="https://redolog.github.io/posts/rd/storage/mysql/performance-optimization/cheatsheet/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.381b1f6e3e5f48c6ea0614a03942519ee25190a2244a20e1a46cffb0b9f4499e.css" integrity="sha256-OBsfbj5fSMbqBhSgOUJRnuJRkKIkSiDhpGz/sLn0SZ4=" rel="preload stylesheet" as="style">
<link rel="preload" href="/favicons/favicon16.ico" as="image">
<link rel="icon" href="https://redolog.github.io/favicons/favicon16.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://redolog.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://redolog.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://redolog.github.io/favicons/favicon_apple_touch.ico">
<link rel="mask-icon" href="https://redolog.github.io/favicons/favicon_apple_touch.ico">
<meta name="theme-color" content="#fff2f2">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="MySQL性能优化cheatsheet" />
<meta property="og:description" content="MySQL性能优化cheatsheet。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://redolog.github.io/posts/rd/storage/mysql/performance-optimization/cheatsheet/" /><meta property="og:image" content="https://redolog.github.io/avatar.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-16T21:30:25&#43;08:00" />
<meta property="article:modified_time" content="2022-05-16T21:30:25&#43;08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://redolog.github.io/avatar.png"/>

<meta name="twitter:title" content="MySQL性能优化cheatsheet"/>
<meta name="twitter:description" content="MySQL性能优化cheatsheet。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://redolog.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "MySQL性能优化cheatsheet",
      "item": "https://redolog.github.io/posts/rd/storage/mysql/performance-optimization/cheatsheet/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL性能优化cheatsheet",
  "name": "MySQL性能优化cheatsheet",
  "description": "MySQL性能优化cheatsheet。\n",
  "keywords": [
    "MySQL", "cheatsheet", "index", "索引优化", "性能优化"
  ],
  "articleBody": "MySQL性能优化cheatsheet。\nSQL执行过程 客户端发送一条查询给服务器； 服务器通过权限检查之后，先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段； 服务器端进行SQL解析、预处理，再由优化器根据该SQL所涉及到的数据表的统计信息进行计算，生成对应的执行计划； MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询； 将结果返回给客户端。 SQL执行的最大瓶颈在于磁盘的IO，即数据的读取；不同SQL的写法，会造成不同的执行计划的执行，而不同的执行计划在IO的上面临完全不一样的数量级，从而造成性能的差距。\n所以，优化SQL，其实就是让查询优化器根据我们的计划选择匹配的执行计划，来减少查询中产生的IO。\nschema(表结构)对性能的影响 冗余数据的处理； 适当的数据冗余可以提高系统的整体查询性能(项目中有些用户信息需要经常一起拿出，可以考虑冗余信息到用户表)；\n大表拆小表，有大数据的列单独拆成小表；\n在一个数据库中，一般不会设计属性过多的表； 在一个数据库中，一般不会有超过500/1000万数据的表(拆表，按照逻辑拆分，按照业务拆分)； 有大数据的列单独拆成小表(富文本、静态数据)； 根据需求的展示设置更合理的表结构；\n把常用属性分离成小表；\n项目中，我们可以根据信息被使用的特征拆成多张表； 减少查询常用属性需要查询的列； 关系数据库的三范式：\n第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库，是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值； 第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。 第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 (不允许有冗余数据) 索引 核心原理 索引和索引的优化：\n索引的原理：把无序的数据变成有序的查询（B+树）； 结构 索引的物理结构：\n数据库文件存储的位置：my.ini配置文件中dataDir对应的数据目录中； 每一个数据库一个文件夹； MYISAM引擎：每一个表(table_name)–\u003e table_name.MYI：存放的是数据表对应的索引信息和索引内容； table_name.FRM：存放的是数据表的结构信息； table_name.MYD：存放的是数据表的内容； InnoDB引擎：每一个表(table_name)–\u003e table_name.frm：存放的是数据表的结构信息； 数据文件和索引文件都是统一存放在ibdata文件中； 索引文件都是额外存在的，对索引的查询和维护都是需要消耗IO的； 索引的结构：\n默认情况下，一旦创建了一个表，这个表设置了主键，那么MySQL会自动的为这个主键创建一个unique的索引； 索引类型： Normal：普通的索引；允许一个索引值后面关联多个行值； UNIQUE：唯一索引；允许一个索引值后面只能有一个行值；之前对列添加唯一约束其实就是为这列添加了一个unique索引；当我们为一个表添加一个主键的时候，其实就是为这个表主键列(设置了非空约束)，并为主键列添加了一个唯一索引； Fulltext：全文检索，MySQL初期的全文仅在MyISAM上支持，目前InnoDB也支持，可参考 innodb-fulltext-index，一般情况下我们不在MySQL层面实践全文搜索； 索引的方法(规定索引的存储结构)： (数据结构，算法基础) b+tree：是一颗树(n叉树）： 使用平衡树实现索引，是mysql中使用最多的索引类型； 在innodb中，存在两种索引类型，第一种是主键索引（primary key），在索引内容中直接保存数据的地址； 第二种是其他索引，在索引内容中保存的是指向主键索引的引用； 所以在使用innodb的时候，要尽量的使用主键索引，速度非常快； b+tree很好地支持了范围查询，叶子节点持有下个数据页的指针； hash：把索引的值做hash运算，并存放到hash表中，使用较少，一般是memory引擎使用； 优点：因为使用hash表存储，按照常理，hash的性能比B-TREE效率高很多。 hash索引的缺点： hash索引只能适用于精确的值比较，=，in，或者\u003c\u003e；无法使用范围查询； 无法使用索引排序； 利弊 索引的利弊：\n索引的好处：\n提高表数据的检索效率； 如果排序的列是索引列(如果查询的列==排序的列[并且在这列上做了索引])，大大降低排序成本； 在分组操作中如果分组条件是索引列，也会提高效率； 索引的问题：\n索引需要额外的维护成本； 因为索引文件是单独存在的文件，对数据的增加，修改，删除，都会产生额外的对索引文件的操作，这些操作需要消耗额外的IO，会降低增/改/删的执行效率； 使用标准 怎么创建索引？\n较频繁的作为查询条件的字段应该创建索引； 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件； 案例分析 作为索引的列，如果不能有效的区分数据，那么这个列就不适合作为索引列；比如(性别，状态不多的状态列)\n举例：\n1 2 -- accountflow 表示账户流水 SELECT sum(amount) FROM accountflow WHERE accountType = 0； 假如把accountType作为索引列，因为accountType只有14种，所以，如果根据accountType来创建索引，最多只能按照1/14的比例过滤掉数据；但是，如果可能出现，只按照该条件查询，那我们就要考虑到其他的提升性能的方式了；\n方案：\n第一种方案：单独创建一个系统摘要表；在这个表里面有一个列叫做系统总充值金额；每次充值成功，增加这个列的值；以后要查询系统总充值金额，只需要从这个系统摘要表中查询；(缺陷：如果充值频率过快，会导致表的锁定问题；) 第二种方案：流水一旦发生了，是不会随着时间改变的；针对这种信息，我们就可以使用增量查询（结算+增量查询）； 创建一张日充值表；记录每一天的充值总金额(beginDate，endDate，totalAmount)，每天使用定时器对当前的充值记录进行结算；日充值报表里面记录只能记录截止昨天的数据； 创建一张月充值表；记录每一个月的充值总金额(beginDate，endDate，totalAmount)，每月最后一天使用定时器对当月的充值记录进行结算(数据源从日充值报表来)； 要查询系统总充值，从月报表中汇总(当前月之前的总充值金额)，再从日充值报表中查询当天之前的日报表数据汇总；再从流水中查询当前截止查询时间的流水；使用另外一张当天流水表记录当天的流水；再把三个数据累加； 更新非常频繁的字段不适合创建索引；原因，索引有维护成本； 不会出现在WHERE 子句中的字段不该创建索引； 索引不是越多越好；(只为必要的列创建索引) 不管你有多少个索引，一次查询至多采用一个索引；(索引和索引之间是独立的) 因为索引和索引之间是独立的，所以说每一个索引都应该是单独维护的；数据的增/改/删，会导致所有的索引都要单独维护； 索引的使用限制： BLOB 和TEXT 类型的列只能创建前缀索引；\nMySQL 目前不支持函数索引（在MySQL中，索引只能是一个列的原始值，不能把列通过计算的值作为索引）； 实例：请查询1981年入职的员工：\n1 SELECT * FROM emp WHERE year(hire_date)='1981'； 问题：查询的列是在过滤之前经过了函数运算；所以，就算hire_date作为索引，year(hire_date)也不会使用索引； 解决方案：\n1 SELECT * FROM emp WHERE hire_date BETWEEN '1981-01-01' AND '1981-12-31'； 在创建一列，这列的值是year(hire_date)，然后把这列的值作为索引； 使用不等于（!= 或者\u003c\u003e）的时候MySQL 无法使用索引\n过滤字段使用了函数运算后（如abs(column)），MySQL 无法使用索引\nJoin 语句中Join 条件字段类型不一致的时候MySQL 无法使用索引\n使用LIKE 操作的时候如果条件以通配符开始（ ‘%abc…’）MySQL 无法使用索引\n字符串是可以用来作为索引的； 字符串创建的索引按照字母顺序排序； 如果使用LIKE，实例：SELECT * FROM userinfo WHERE realName LIKE ‘吴%’；这种情况是可以使用索引的； 但是LIKE ‘_嘉’ 或者LIKE ‘%嘉’都是不能使用索引的； 使用非等值查询的时候MySQL 无法使用Hash 索引\n单列索引和复合索引： 因为一个查询一次至多只能使用一个索引，所以，如果都使用单值索引(一个列一个索引)，在数据量较大的情况下，不能很好的区分数据； 所以，MySQL引入了多值索引(复合索引)； 复合索引就是由多列的值组成的索引；并且(注意)，多列的索引是有顺序的!!!! 复合索引的原理：就是类似orderby(orderby后面可以跟多个排序条件order by hire_date，username desc)； 就是在排序和分组(创建倒排表的时候)，按照多个列进行排序和合并； 1 2 3 4 SELECT * FROM accountflow WHERE actionTime \u003c 'xxxxx' AND account_id = 5 可以使用actionTime+account_id的复合索引； SELECT * FROM accountflow WHERE actionTime \u003c 'xxxxx' 可以使用actionTime+account_id的复合索引； SELECT * FROM accountflow WHERE account_id = 5 不可以使用actionTime+account_id的复合索引； SELECT * FROM accountflow WHERE account_id = 5 AND actionTime \u003c 'xxxxx' 不可以使用actionTime+account_id的复合索引； 复合索引，在查询的时候，遵守向左原则；只要在查询的时候，是按照复合索引从左到右的顺序依次查询，不管查询条件是否完全满足所有的符合索引的列，都可以使用部分的符合索引； 在实际应用中，基本上都使用复合索引； SQL优化 查看MySQL的执行计划和执行明细状态(explain+profiling)\nExplain：可以让我们查看MySQL执行一条SQL所选择的执行计划； Profiling：可以用来准确定位一条SQL的性能瓶颈； EXPLAIN： 使用方式： explain SQL； 返回结果： ID：执行查询的序列号； select_type：使用的查询类型 DEPENDENT SUBQUERY：子查询中内层的第一个SELECT，依赖于外部查询的结果集； DEPENDENT UNION：子查询中的UNION，且为UNION 中从第二个SELECT 开始的后面所有SELECT，同样依赖于外部查询的结果集； PRIMARY：子查询中的最外层查询，注意并不是主键查询； SIMPLE：除子查询或者UNION 之外的其他查询； SUBQUERY：子查询内层查询的第一个SELECT，结果不依赖于外部查询结果集； UNCACHEABLE SUBQUERY：结果集无法缓存的子查询； UNION：UNION 语句中第二个SELECT 开始的后面所有SELECT，第一个SELECT 为PRIMARY UNION RESULT：UNION 中的合并结果； table：这次查询访问的数据表； type：对表所使用的访问方式： all：全表扫描 const：读常量，且最多只会有一条记录匹配，由于是常量，所以实际上只需要读一次； eq_ref：最多只会有一条匹配结果，一般是通过主键或者唯一键索引来访问； fulltext：全文检索，针对full text索引列； index：全索引扫描； index_merge：查询中同时使用两个（或更多）索引，然后对索引结果进行merge 之后再读取表数据； index_subquery：子查询中的返回结果字段组合是一个索引（或索引组合），但不是一个主键或者唯一索引； rang：索引范围扫描； ref：Join 语句中被驱动表索引引用查询； ref_or_null：与ref 的唯一区别就是在使用索引引用查询之外再增加一个空值的查询； system：系统表，表中只有一行数据； unique_subquery：子查询中的返回结果字段组合是主键或者唯一约束； possible_keys：可选的索引；如果没有使用索引，为null； key：最终选择的索引； key_len：被选择的索引长度； ref：过滤的方式，比如const（常量），column（join），func（某个函数）； rows：查询优化器通过收集到的统计信息估算出的查询条数； Extra：查询中每一步实现的额外细节信息 Distinct：查找distinct 值，所以当mysql 找到了第一条匹配的结果后，将停止该值的查询而转为后面其他值的查询； Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问null值的使用使用； Impossible WHERE noticed after reading const tables：MySQL Query Optimizer 通过收集到的统计信息判断出不可能存在结果； No tables：Query 语句中使用FROM DUAL 或者不包含任何FROM 子句； Not exists：在某些左连接中MySQL Query Optimizer 所通过改变原有Query 的组成而使用的优化方法，可以部分减少数据访问次数； Select tables optimized away：当我们使用某些聚合函数来访问存在索引的某个字段的时候，MySQL Query Optimizer 会通过索引而直接一次定位到所需的数据行完成整个查询。当然，前提是在Query 中不能有GROUP BY 操作。如使用MIN()或者MAX（）的时候； Using filesort：当我们的Query 中包含ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。 Using index：所需要的数据只需要在Index 即可全部获得而不需要再到表中取数据； Using index for group-by：数据访问和Using index 一样，所需数据只需要读取索引即可，而当Query 中使用了GROUP BY 或者DISTINCT 子句的时候，如果分组字段也在索引中，Extra 中的信息就会是Using index for group-by； Using temporary：当MySQL 在某些操作中必须使用临时表的时候，在Extra 信息中就会出现Using temporary 。主要常见于GROUP BY 和ORDER BY 等操作中。 Using where：如果我们不是读取表的所有数据，或者不是仅仅通过索引就可以获取所有需要的数据，则会出现Using where 信息； Using where with pushed condition：这是一个仅仅在NDBCluster 存储引擎中才会出现的信息，而且还需要通过打开Condition Pushdown 优化功能才可能会被使用。控制参数为engine_condition_pushdown 。 profiling： Query Profiler是MySQL5.1之后提供的一个很方便的用于诊断Query执行的工具，能够准确的获取一条查询执行过程中的CPU，IO等情况；\n开启profiling：set profiling=1； 执行QUERY，在profiling过程中所有的query都可以记录下来； 查看记录的query：show profiles； 选择要查看的profile：show profile cpu， block io for query 6； status是执行SQL的详细过程； Duration：执行的具体时间； CPU_user：用户CPU时间； CPU_system：系统CPU时间； Block_ops_in：IO输入次数； Block_ops_out：IO输出次数；\nprofiling只对本次会话有效；\nJOIN： JOIN的原理： 在mysql中使用Nested Loop Join来实现join； A JOIN B：通过A表的结果集作为循环基础，一条一条的通过结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果； JOIN的优化原则： 尽可能减少Join 语句中的Nested Loop 的循环总次数，用小结果集驱动大结果集； 优先优化Nested Loop 的内层循环； 保证Join 语句中被驱动表上Join 条件字段已经被索引； 扩大join buffer的大小； 优化原则 原则一：选择需要优化的SQL 选择需要优化的SQL：\n不是所有的SQL都需要优化，在优化的过程中，首选更需要优化的SQL； 怎么选择?优先选择优化高并发低消耗的SQL；\n1小时请求1W次，1次10个IO； 1小时请求10次，1次1W个IO； 考虑： 从单位时间产生的IO总数来说，相同的； 针对一个SQL，如果我能把10个IO变成7个IO，一小时减少3W个IO； 针对第二个SQL，如果能把1W个IO变成7K个IO，一小时减少3W个IO； 从优化难度上讲，1W-\u003e7K难的多； 从整体性能上来说，第一个SQL的优化能够极大的提升系统整体的性能；第二个SQL慢一点，无非也就是10个连接查询慢一点； 定位性能瓶颈；\nSQL运行较慢有两个影响原因，IO和CPU，明确性能瓶颈所在； 明确优化目标； 原则二：从Explain和Profile入手 任何SQL的优化，都从Explain语句开始；Explain语句能够得到数据库执行该SQL选择的执行计划； 首先明确需要的执行计划，再使用Explain检查； 使用profile明确SQL的问题和优化的结果； 原则三：永远用小结果集驱动大的结果集 原则四：在索引中完成排序 原则五：使用最小Columns 减少网络传输数据量； 特别是需要使用column排序的时候。MySQL排序原理，是把所有的column数据全部取出，在排序缓存区排序，再返回结果；如果column数据量大，排序区容量不够的时候，就会使用先column排序，再取数据，再返回的多次请求方式； 原则六：使用最有效的过滤条件 过多的WHERE条件不一定能够提高访问性能； 一定要让WHERE条件使用自己预期的执行计划； 原则七：避免复杂的JOIN和子查询 复杂的JOIN和子查询，需要锁定过多的资源，MySQL在大量并发情况下处理锁定性能下降较快； 不要过多依赖SQL的功能，把复杂的SQL拆分为简单的SQL； MySQL子查询性能较低，应尽量避免使用； innodb_buffer和事务 Innodb_buffer_pool_size：innodb的缓存，可以用于缓存索引，同时还会缓存实际的数据； innodb_buffer_pool_size 参数用来设置Innodb 最主要的Buffer(Innodb_Buffer_Pool)的大小，对Innodb 整体性能影响也最大，可以按需要设置大一些；\ninnodb中的事务处理：\n理解Innodb事务机制： 事务在buffer中对数据进行修改； 事务的变化记录在事务日志中； 在合适的时机同步事务日志中的数据到数据库中； 所以什么时候提交事务日志文件，对系统性能影响较大，可以通过设置innodb_flush_log_at_trx_commit来修改事务日志同步时机： innodb_flush_log_at_trx_commit = 0，每1秒钟同步一次事务日志文件； innodb_flush_log_at_trx_commit = 1. 默认设置，每一个事务完成之后，同步一次事务日志文件； innodb_flush_log_at_trx_commit = 2. 事务完成之后，写到事务日志文件中，等到日志覆盖再同步数据； 注意，1性能最差，2不能完全保证数据是写到数据文件中，如果宕机，可能会有数据丢失现象，但性能最高；1性能和安全性居中； 主从架构 简单理解下主从架构诞生的背景： 应用开发中常见的由量带来的问题：系统太卡！\n研发判断是web服务器的压力过大，此时我们可以增加web服务器的配置、数量，由单点增加量后借助负载均衡来分发流量，这样可以解决web服务器压力过大的问题。 如果还是卡，通过查看MySQL监控发现QPS上来了，单点数据库遇到瓶颈，可以考虑在应用层增加缓存层，此时MySQL单点压力被分发了，问题解决。 如果还是卡，并且已经实施了上述方案，分析应用使用MySQL的姿势，发现大多数请求都是查询。此时可以考虑主从架构，使用从节点分担主节点读的压力。 MySQL主从复制的文档，默认复制操作是异步的，因此在TPS突刺时会有延迟的现象，具体优化可参见官方配置文档。\n考虑到主从复制的延迟问题，研发在应用设计实现时需做提前考虑：\n所有写操作由主节点完成； 对读写一致性实时性要求高的业务需在应用层指定策略（一直读主、延迟读从）； 对读写一致性实时性要求不高的业务可以宽松处理； 事务需保证读写都在一个实例上； 主从的大致流程：\n主从同步的目的是要保证从节点与主节点一致的DDL/DML/TCL语句的执行状态，MySQL使用binlog记录变更。\n打开binlog，主节点记录所有DDL/DML/TCL语句； 主节点使用被动注册的方式联通主从节点，从节点主动请求主节点，这种方式下增删从节点对主节点无影响； 从节点起一个线程向主节点请求，询问某个点之后更新的数据； 主节点收到从节点请求，读取binlog，返回给从节点； 从节点获取响应之后将数据写入relaylog，relaylog记录主节点请求返回的变更； 从节点开启另外专用的线程处理relaylog； 2024.02.27补充图例： Ref 后端思维之数据库性能优化方案 ",
  "wordCount" : "8263",
  "inLanguage": "en",
  "datePublished": "2022-05-16T21:30:25+08:00",
  "dateModified": "2022-05-16T21:30:25+08:00",
  "author":[{
    "@type": "Person",
    "name": "DragonSong"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://redolog.github.io/posts/rd/storage/mysql/performance-optimization/cheatsheet/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "宋惠龙的博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://redolog.github.io/favicons/favicon16.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-9EJ8N0FFCW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9EJ8N0FFCW');
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://redolog.github.io/" accesskey="h" title="宋惠龙的博客 (Alt + H)">
                <img src="https://redolog.github.io/favicons/favicon16.ico" alt="logo" aria-label="logo"
                    height="35">宋惠龙的博客</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://redolog.github.io/archives/" title="文章归档">
                    <span>文章归档</span>
                </a>
            </li>
            <li>
                <a href="https://redolog.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/redolog" title="GitHub">
                    <span><i class='fab fa-github fa-fw'></i></span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://redolog.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://redolog.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      MySQL性能优化cheatsheet
    </h1>
    <div class="post-meta"><span title='2022-05-16 21:30:25 +0800 CST'>May 16, 2022</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;DragonSong

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#sql%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b" aria-label="SQL执行过程">SQL执行过程</a></li>
                    <li>
                        <a href="#schema%e8%a1%a8%e7%bb%93%e6%9e%84%e5%af%b9%e6%80%a7%e8%83%bd%e7%9a%84%e5%bd%b1%e5%93%8d" aria-label="schema(表结构)对性能的影响">schema(表结构)对性能的影响</a></li>
                    <li>
                        <a href="#%e7%b4%a2%e5%bc%95" aria-label="索引">索引</a><ul>
                            
                    <li>
                        <a href="#%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86" aria-label="核心原理">核心原理</a></li>
                    <li>
                        <a href="#%e7%bb%93%e6%9e%84" aria-label="结构">结构</a></li>
                    <li>
                        <a href="#%e5%88%a9%e5%bc%8a" aria-label="利弊">利弊</a></li>
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8%e6%a0%87%e5%87%86" aria-label="使用标准">使用标准</a><ul>
                            
                    <li>
                        <a href="#%e6%a1%88%e4%be%8b%e5%88%86%e6%9e%90" aria-label="案例分析">案例分析</a></li>
                    <li>
                        <a href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bd%bf%e7%94%a8%e9%99%90%e5%88%b6" aria-label="索引的使用限制：">索引的使用限制：</a></li>
                    <li>
                        <a href="#%e5%8d%95%e5%88%97%e7%b4%a2%e5%bc%95%e5%92%8c%e5%a4%8d%e5%90%88%e7%b4%a2%e5%bc%95" aria-label="单列索引和复合索引：">单列索引和复合索引：</a></li>
                    <li>
                        <a href="#sql%e4%bc%98%e5%8c%96" aria-label="SQL优化">SQL优化</a><ul>
                            
                    <li>
                        <a href="#explain" aria-label="EXPLAIN：">EXPLAIN：</a></li>
                    <li>
                        <a href="#profiling" aria-label="profiling：">profiling：</a></li></ul>
                    </li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#join" aria-label="JOIN：">JOIN：</a></li>
                    <li>
                        <a href="#%e4%bc%98%e5%8c%96%e5%8e%9f%e5%88%99" aria-label="优化原则">优化原则</a><ul>
                            
                    <li>
                        <a href="#%e5%8e%9f%e5%88%99%e4%b8%80%e9%80%89%e6%8b%a9%e9%9c%80%e8%a6%81%e4%bc%98%e5%8c%96%e7%9a%84sql" aria-label="原则一：选择需要优化的SQL">原则一：选择需要优化的SQL</a></li>
                    <li>
                        <a href="#%e5%8e%9f%e5%88%99%e4%ba%8c%e4%bb%8eexplain%e5%92%8cprofile%e5%85%a5%e6%89%8b" aria-label="原则二：从Explain和Profile入手">原则二：从Explain和Profile入手</a></li>
                    <li>
                        <a href="#%e5%8e%9f%e5%88%99%e4%b8%89%e6%b0%b8%e8%bf%9c%e7%94%a8%e5%b0%8f%e7%bb%93%e6%9e%9c%e9%9b%86%e9%a9%b1%e5%8a%a8%e5%a4%a7%e7%9a%84%e7%bb%93%e6%9e%9c%e9%9b%86" aria-label="原则三：永远用小结果集驱动大的结果集">原则三：永远用小结果集驱动大的结果集</a></li>
                    <li>
                        <a href="#%e5%8e%9f%e5%88%99%e5%9b%9b%e5%9c%a8%e7%b4%a2%e5%bc%95%e4%b8%ad%e5%ae%8c%e6%88%90%e6%8e%92%e5%ba%8f" aria-label="原则四：在索引中完成排序">原则四：在索引中完成排序</a></li>
                    <li>
                        <a href="#%e5%8e%9f%e5%88%99%e4%ba%94%e4%bd%bf%e7%94%a8%e6%9c%80%e5%b0%8fcolumns" aria-label="原则五：使用最小Columns">原则五：使用最小Columns</a></li>
                    <li>
                        <a href="#%e5%8e%9f%e5%88%99%e5%85%ad%e4%bd%bf%e7%94%a8%e6%9c%80%e6%9c%89%e6%95%88%e7%9a%84%e8%bf%87%e6%bb%a4%e6%9d%a1%e4%bb%b6" aria-label="原则六：使用最有效的过滤条件">原则六：使用最有效的过滤条件</a></li>
                    <li>
                        <a href="#%e5%8e%9f%e5%88%99%e4%b8%83%e9%81%bf%e5%85%8d%e5%a4%8d%e6%9d%82%e7%9a%84join%e5%92%8c%e5%ad%90%e6%9f%a5%e8%af%a2" aria-label="原则七：避免复杂的JOIN和子查询">原则七：避免复杂的JOIN和子查询</a></li></ul>
                    </li>
                    <li>
                        <a href="#innodb_buffer%e5%92%8c%e4%ba%8b%e5%8a%a1" aria-label="innodb_buffer和事务">innodb_buffer和事务</a></li>
                    <li>
                        <a href="#%e4%b8%bb%e4%bb%8e%e6%9e%b6%e6%9e%84" aria-label="主从架构">主从架构</a></li>
                    <li>
                        <a href="#ref" aria-label="Ref">Ref</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p><code>MySQL</code>性能优化<code>cheatsheet</code>。</p>
<h1 id="sql执行过程">SQL执行过程<a hidden class="anchor" aria-hidden="true" href="#sql执行过程">#</a></h1>
<ol>
<li>客户端发送一条查询给服务器；</li>
<li>服务器通过权限检查之后，先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；</li>
<li>服务器端进行<code>SQL</code>解析、预处理，再由优化器根据该SQL所涉及到的数据表的统计信息进行计算，生成对应的执行计划；</li>
<li><code>MySQL</code>根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li>
<li>将结果返回给客户端。</li>
</ol>
<p><img loading="lazy" src="/posts/rd/storage/mysql/how_sql_executed_on_mysql_server.jpg" alt="截图自《MySQL是怎样运行的》"  />
</p>
<p><code>SQL</code>执行的最大瓶颈在于磁盘的<code>IO</code>，即数据的读取；不同<code>SQL</code>的写法，会造成不同的执行计划的执行，而不同的执行计划在<code>IO</code>的上面临完全不一样的数量级，从而造成性能的差距。</p>
<p>所以，优化<code>SQL</code>，其实就是让查询优化器根据我们的计划选择匹配的执行计划，来减少查询中产生的<code>IO</code>。</p>
<h1 id="schema表结构对性能的影响">schema(表结构)对性能的影响<a hidden class="anchor" aria-hidden="true" href="#schema表结构对性能的影响">#</a></h1>
<ol>
<li>
<p>冗余数据的处理；
适当的数据冗余可以提高系统的整体查询性能(项目中有些用户信息需要经常一起拿出，可以考虑冗余信息到用户表)；</p>
</li>
<li>
<p>大表拆小表，有大数据的列单独拆成小表；</p>
<ol>
<li>在一个数据库中，一般不会设计属性过多的表；</li>
<li>在一个数据库中，一般不会有超过500/1000万数据的表(拆表，按照逻辑拆分，按照业务拆分)；</li>
<li>有大数据的列单独拆成小表(富文本、静态数据)；</li>
</ol>
</li>
<li>
<p>根据需求的展示设置更合理的表结构；</p>
</li>
<li>
<p>把常用属性分离成小表；</p>
<ol>
<li>项目中，我们可以根据信息被使用的特征拆成多张表；</li>
<li>减少查询常用属性需要查询的列；</li>
</ol>
</li>
</ol>
<blockquote>
<p>关系数据库的三范式：</p>
<ul>
<li>第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库，是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值；</li>
<li>第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。</li>
<li>第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 (不允许有冗余数据)</li>
</ul>
</blockquote>
<h1 id="索引">索引<a hidden class="anchor" aria-hidden="true" href="#索引">#</a></h1>
<h2 id="核心原理">核心原理<a hidden class="anchor" aria-hidden="true" href="#核心原理">#</a></h2>
<p>索引和索引的优化：</p>
<ol>
<li>索引的原理：把无序的数据变成有序的查询（<code>B+树</code>）；</li>
</ol>
<h2 id="结构">结构<a hidden class="anchor" aria-hidden="true" href="#结构">#</a></h2>
<ol>
<li>
<p>索引的物理结构：</p>
<ol>
<li>数据库文件存储的位置：<code>my.ini</code>配置文件中<code>dataDir</code>对应的数据目录中；</li>
<li>每一个数据库一个文件夹；
<ol>
<li><code>MYISAM</code>引擎：每一个表(table_name)&ndash;&gt;
<ul>
<li><code>table_name.MYI</code>：存放的是数据表对应的索引信息和索引内容；</li>
<li><code>table_name.FRM</code>：存放的是数据表的结构信息；</li>
<li><code>table_name.MYD</code>：存放的是数据表的内容；</li>
</ul>
</li>
<li><code>InnoDB</code>引擎：每一个表(table_name)&ndash;&gt;
<ul>
<li><code>table_name.frm</code>：存放的是数据表的结构信息；</li>
<li>数据文件和索引文件都是统一存放在<code>ibdata</code>文件中；</li>
</ul>
</li>
<li>索引文件都是额外存在的，对索引的查询和维护都是需要消耗<code>IO</code>的；</li>
</ol>
</li>
</ol>
</li>
<li>
<p>索引的结构：</p>
<ol>
<li>默认情况下，一旦创建了一个表，这个表设置了主键，那么MySQL会自动的为这个主键创建一个unique的索引；</li>
<li>索引类型：
<ol>
<li>Normal：普通的索引；允许一个索引值后面关联多个行值；</li>
<li>UNIQUE：唯一索引；允许一个索引值后面只能有一个行值；之前对列添加唯一约束其实就是为这列添加了一个unique索引；当我们为一个表添加一个主键的时候，其实就是为这个表主键列(设置了非空约束)，并为主键列添加了一个唯一索引；</li>
<li>Fulltext：全文检索，<code>MySQL</code>初期的全文仅在<code>MyISAM</code>上支持，目前<code>InnoDB</code>也支持，可参考 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-fulltext-index.html#innodb-fulltext-index-design">innodb-fulltext-index</a>，一般情况下我们不在<code>MySQL</code>层面实践全文搜索；</li>
</ol>
</li>
<li>索引的方法(规定索引的存储结构)：        (数据结构，算法基础)
<ol>
<li><code>b+tree</code>：是一颗树(n叉树）：
<ul>
<li>使用平衡树实现索引，是mysql中使用最多的索引类型；</li>
<li>在innodb中，存在两种索引类型，第一种是主键索引（primary key），在索引内容中直接保存数据的地址；</li>
<li>第二种是其他索引，在索引内容中保存的是指向主键索引的引用；</li>
<li>所以在使用innodb的时候，要尽量的使用主键索引，速度非常快；</li>
<li><code>b+tree</code>很好地支持了范围查询，<strong>叶子节点持有下个数据页的指针</strong>；</li>
</ul>
</li>
<li>hash：把索引的值做hash运算，并存放到hash表中，使用较少，一般是memory引擎使用；
<ol>
<li>优点：因为使用hash表存储，按照常理，hash的性能比B-TREE效率高很多。</li>
<li>hash索引的缺点：
<ol>
<li>hash索引只能适用于精确的值比较，=，in，或者&lt;&gt;；无法使用范围查询；</li>
<li>无法使用索引排序；</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="利弊">利弊<a hidden class="anchor" aria-hidden="true" href="#利弊">#</a></h2>
<p>索引的利弊：</p>
<ol>
<li>
<p>索引的好处：</p>
<ol>
<li>提高表数据的检索效率；</li>
<li>如果排序的列是索引列(如果查询的列==排序的列[并且在这列上做了索引])，大大降低排序成本；</li>
<li>在分组操作中如果分组条件是索引列，也会提高效率；</li>
</ol>
</li>
<li>
<p>索引的问题：</p>
<ul>
<li>索引需要额外的维护成本；</li>
<li>因为索引文件是单独存在的文件，对数据的增加，修改，删除，都会产生额外的对索引文件的操作，这些操作需要消耗额外的IO，会降低增/改/删的执行效率；</li>
</ul>
</li>
</ol>
<h2 id="使用标准">使用标准<a hidden class="anchor" aria-hidden="true" href="#使用标准">#</a></h2>
<p>怎么创建索引？</p>
<ol>
<li>较频繁的作为查询条件的字段应该创建索引；</li>
<li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件；</li>
</ol>
<h3 id="案例分析">案例分析<a hidden class="anchor" aria-hidden="true" href="#案例分析">#</a></h3>
<blockquote>
<p>作为索引的列，如果不能有效的区分数据，那么这个列就不适合作为索引列；比如(性别，状态不多的状态列)</p>
<p>举例：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- accountflow 表示账户流水
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">sum</span>(amount) <span style="color:#66d9ef">FROM</span> accountflow <span style="color:#66d9ef">WHERE</span> accountType <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">；</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>假如把<code>accountType</code>作为索引列，因为<code>accountType</code>只有14种，所以，如果根据<code>accountType</code>来创建索引，最多只能按照1/14的比例过滤掉数据；但是，如果可能出现，只按照该条件查询，那我们就要考虑到其他的提升性能的方式了；</p>
<p>方案：</p>
<ul>
<li>第一种方案：单独创建一个系统摘要表；在这个表里面有一个列叫做系统总充值金额；每次充值成功，增加这个列的值；以后要查询系统总充值金额，只需要从这个系统摘要表中查询；(缺陷：如果充值频率过快，会导致表的锁定问题；)</li>
<li>第二种方案：流水一旦发生了，是不会随着时间改变的；针对这种信息，我们就可以使用增量查询（结算+增量查询）；
<ol>
<li>创建一张日充值表；记录每一天的充值总金额(beginDate，endDate，totalAmount)，每天使用定时器对当前的充值记录进行结算；日充值报表里面记录只能记录截止昨天的数据；</li>
<li>创建一张月充值表；记录每一个月的充值总金额(beginDate，endDate，totalAmount)，每月最后一天使用定时器对当月的充值记录进行结算(数据源从日充值报表来)；</li>
<li>要查询系统总充值，从月报表中汇总(当前月之前的总充值金额)，再从日充值报表中查询当天之前的日报表数据汇总；再从流水中查询当前截止查询时间的流水；使用另外一张当天流水表记录当天的流水；再把三个数据累加；</li>
</ol>
</li>
</ul>
</blockquote>
<ol>
<li>更新非常频繁的字段不适合创建索引；原因，索引有维护成本；</li>
<li>不会出现在WHERE 子句中的字段不该创建索引；</li>
<li>索引不是越多越好；(只为必要的列创建索引)
<ol>
<li>不管你有多少个索引，一次查询至多采用一个索引；(索引和索引之间是独立的)</li>
<li>因为索引和索引之间是独立的，所以说每一个索引都应该是单独维护的；数据的增/改/删，会导致所有的索引都要单独维护；</li>
</ol>
</li>
</ol>
<h3 id="索引的使用限制">索引的使用限制：<a hidden class="anchor" aria-hidden="true" href="#索引的使用限制">#</a></h3>
<ol>
<li>
<p><code>BLOB</code> 和<code>TEXT</code> 类型的列只能创建前缀索引；</p>
</li>
<li>
<p><code>MySQL</code> 目前不支持函数索引（在<code>MySQL</code>中，索引只能是一个列的原始值，不能把列通过计算的值作为索引）；
实例：请查询1981年入职的员工：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> emp <span style="color:#66d9ef">WHERE</span> <span style="color:#66d9ef">year</span>(hire_date)<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;1981&#39;</span><span style="color:#960050;background-color:#1e0010">；</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>问题：查询的列是在过滤之前经过了函数运算；所以，就算<code>hire_date</code>作为索引，<code>year(hire_date)</code>也不会使用索引；
解决方案：</p>
<ol>
<li>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> emp <span style="color:#66d9ef">WHERE</span> hire_date <span style="color:#66d9ef">BETWEEN</span> <span style="color:#e6db74">&#39;1981-01-01&#39;</span> <span style="color:#66d9ef">AND</span> <span style="color:#e6db74">&#39;1981-12-31&#39;</span><span style="color:#960050;background-color:#1e0010">；</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>在创建一列，这列的值是year(hire_date)，然后把这列的值作为索引；</li>
</ol>
</li>
<li>
<p>使用不等于（!= 或者&lt;&gt;）的时候MySQL 无法使用索引</p>
</li>
<li>
<p>过滤字段使用了函数运算后（如abs(column)），MySQL 无法使用索引</p>
</li>
<li>
<p>Join 语句中Join 条件字段类型不一致的时候MySQL 无法使用索引</p>
</li>
<li>
<p>使用LIKE 操作的时候如果条件以通配符开始（ &lsquo;%abc&hellip;&rsquo;）MySQL 无法使用索引</p>
<ol>
<li>字符串是可以用来作为索引的；</li>
<li>字符串创建的索引按照字母顺序排序；</li>
<li>如果使用LIKE，实例：SELECT * FROM userinfo WHERE realName LIKE &lsquo;吴%&rsquo;；这种情况是可以使用索引的；
但是LIKE &lsquo;_嘉&rsquo; 或者LIKE &lsquo;%嘉&rsquo;都是不能使用索引的；</li>
</ol>
</li>
<li>
<p>使用非等值查询的时候MySQL 无法使用Hash 索引</p>
</li>
</ol>
<h3 id="单列索引和复合索引">单列索引和复合索引：<a hidden class="anchor" aria-hidden="true" href="#单列索引和复合索引">#</a></h3>
<ol>
<li>因为一个查询一次至多只能使用一个索引，所以，如果都使用单值索引(一个列一个索引)，在数据量较大的情况下，不能很好的区分数据；</li>
<li>所以，<code>MySQL</code>引入了多值索引(复合索引)；
复合索引就是由多列的值组成的索引；并且(注意)，多列的索引是有顺序的!!!!</li>
<li>复合索引的原理：就是类似orderby(orderby后面可以跟多个排序条件order by hire_date，username desc)；
<ul>
<li>就是在排序和分组(创建倒排表的时候)，按照多个列进行排序和合并；</li>
</ul>
</li>
</ol>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>    <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> accountflow <span style="color:#66d9ef">WHERE</span> actionTime <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;xxxxx&#39;</span> <span style="color:#66d9ef">AND</span> account_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> <span style="color:#960050;background-color:#1e0010">可以使用</span>actionTime<span style="color:#f92672">+</span>account_id<span style="color:#960050;background-color:#1e0010">的复合索引；</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> accountflow <span style="color:#66d9ef">WHERE</span> actionTime <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;xxxxx&#39;</span> <span style="color:#960050;background-color:#1e0010">可以使用</span>actionTime<span style="color:#f92672">+</span>account_id<span style="color:#960050;background-color:#1e0010">的复合索引；</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> accountflow <span style="color:#66d9ef">WHERE</span> account_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> <span style="color:#960050;background-color:#1e0010">不可以使用</span>actionTime<span style="color:#f92672">+</span>account_id<span style="color:#960050;background-color:#1e0010">的复合索引；</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> accountflow <span style="color:#66d9ef">WHERE</span> account_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> <span style="color:#66d9ef">AND</span> actionTime <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;xxxxx&#39;</span> <span style="color:#960050;background-color:#1e0010">不可以使用</span>actionTime<span style="color:#f92672">+</span>account_id<span style="color:#960050;background-color:#1e0010">的复合索引；</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>复合索引，在查询的时候，遵守向左原则；只要在查询的时候，是按照复合索引从左到右的顺序依次查询，不管查询条件是否完全满足所有的符合索引的列，都可以使用部分的符合索引；</li>
<li>在实际应用中，基本上都使用复合索引；</li>
</ol>
<h3 id="sql优化">SQL优化<a hidden class="anchor" aria-hidden="true" href="#sql优化">#</a></h3>
<p>查看MySQL的执行计划和执行明细状态(explain+profiling)</p>
<ol>
<li>Explain：可以让我们查看MySQL执行一条SQL所选择的执行计划；</li>
<li>Profiling：可以用来准确定位一条SQL的性能瓶颈；</li>
</ol>
<h4 id="explain">EXPLAIN：<a hidden class="anchor" aria-hidden="true" href="#explain">#</a></h4>
<ol>
<li>使用方式：
explain SQL；</li>
<li>返回结果：
<ol>
<li>ID：执行查询的序列号；</li>
<li>select_type：使用的查询类型
<ol>
<li>DEPENDENT SUBQUERY：子查询中内层的第一个SELECT，依赖于外部查询的结果集；</li>
<li>DEPENDENT UNION：子查询中的UNION，且为UNION 中从第二个SELECT 开始的后面所有SELECT，同样依赖于外部查询的结果集；</li>
<li>PRIMARY：子查询中的最外层查询，注意并不是主键查询；</li>
<li>SIMPLE：除子查询或者UNION 之外的其他查询；</li>
<li>SUBQUERY：子查询内层查询的第一个SELECT，结果不依赖于外部查询结果集；</li>
<li>UNCACHEABLE SUBQUERY：结果集无法缓存的子查询；</li>
<li>UNION：UNION 语句中第二个SELECT 开始的后面所有SELECT，第一个SELECT 为PRIMARY</li>
<li>UNION RESULT：UNION 中的合并结果；</li>
</ol>
</li>
<li>table：这次查询访问的数据表；</li>
<li>type：对表所使用的访问方式：
<ol>
<li>all：全表扫描</li>
<li>const：读常量，且最多只会有一条记录匹配，由于是常量，所以实际上只需要读一次；</li>
<li>eq_ref：最多只会有一条匹配结果，一般是通过主键或者唯一键索引来访问；</li>
<li>fulltext：全文检索，针对full text索引列；</li>
<li>index：全索引扫描；</li>
<li>index_merge：查询中同时使用两个（或更多）索引，然后对索引结果进行merge 之后再读取表数据；</li>
<li>index_subquery：子查询中的返回结果字段组合是一个索引（或索引组合），但不是一个主键或者唯一索引；</li>
<li>rang：索引范围扫描；</li>
<li>ref：Join 语句中被驱动表索引引用查询；</li>
<li>ref_or_null：与ref 的唯一区别就是在使用索引引用查询之外再增加一个空值的查询；</li>
<li>system：系统表，表中只有一行数据；</li>
<li>unique_subquery：子查询中的返回结果字段组合是主键或者唯一约束；</li>
</ol>
</li>
<li>possible_keys：可选的索引；如果没有使用索引，为null；</li>
<li>key：最终选择的索引；</li>
<li>key_len：被选择的索引长度；</li>
<li>ref：过滤的方式，比如const（常量），column（join），func（某个函数）；</li>
<li>rows：查询优化器通过收集到的统计信息估算出的查询条数；</li>
<li>Extra：查询中每一步实现的额外细节信息
<ol>
<li>Distinct：查找distinct 值，所以当mysql 找到了第一条匹配的结果后，将停止该值的查询而转为后面其他值的查询；</li>
<li>Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问null值的使用使用；</li>
<li>Impossible WHERE noticed after reading const tables：MySQL Query Optimizer 通过收集到的统计信息判断出不可能存在结果；</li>
<li>No tables：Query 语句中使用FROM DUAL 或者不包含任何FROM 子句；</li>
<li>Not exists：在某些左连接中MySQL Query Optimizer 所通过改变原有Query 的组成而使用的优化方法，可以部分减少数据访问次数；</li>
<li>Select tables optimized away：当我们使用某些聚合函数来访问存在索引的某个字段的时候，MySQL Query Optimizer 会通过索引而直接一次定位到所需的数据行完成整个查询。当然，前提是在Query 中不能有GROUP BY 操作。如使用MIN()或者MAX（）的时候；</li>
<li>Using filesort：当我们的Query 中包含ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。</li>
<li>Using index：所需要的数据只需要在Index 即可全部获得而不需要再到表中取数据；</li>
<li>Using index for group-by：数据访问和Using index 一样，所需数据只需要读取索引即可，而当Query 中使用了GROUP BY 或者DISTINCT 子句的时候，如果分组字段也在索引中，Extra 中的信息就会是Using index for group-by；</li>
<li>Using temporary：当MySQL 在某些操作中必须使用临时表的时候，在Extra 信息中就会出现Using temporary 。主要常见于GROUP BY 和ORDER BY 等操作中。</li>
<li>Using where：如果我们不是读取表的所有数据，或者不是仅仅通过索引就可以获取所有需要的数据，则会出现Using where 信息；</li>
<li>Using where with pushed condition：这是一个仅仅在NDBCluster 存储引擎中才会出现的信息，而且还需要通过打开Condition Pushdown 优化功能才可能会被使用。控制参数为engine_condition_pushdown 。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="profiling">profiling：<a hidden class="anchor" aria-hidden="true" href="#profiling">#</a></h4>
<p>Query Profiler是MySQL5.1之后提供的一个很方便的用于诊断Query执行的工具，能够准确的获取一条查询执行过程中的CPU，IO等情况；</p>
<ol>
<li>开启profiling：set profiling=1；</li>
<li>执行QUERY，在profiling过程中所有的query都可以记录下来；</li>
<li>查看记录的query：show profiles；</li>
<li>选择要查看的profile：show profile cpu， block io for query 6；</li>
</ol>
<p>status是执行SQL的详细过程；
Duration：执行的具体时间；
CPU_user：用户CPU时间；
CPU_system：系统CPU时间；
Block_ops_in：IO输入次数；
Block_ops_out：IO输出次数；</p>
<p>profiling只对本次会话有效；</p>
<h1 id="join">JOIN：<a hidden class="anchor" aria-hidden="true" href="#join">#</a></h1>
<ol>
<li>JOIN的原理：
在mysql中使用Nested Loop Join来实现join；
A JOIN B：通过A表的结果集作为循环基础，一条一条的通过结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果；</li>
<li>JOIN的优化原则：</li>
<li>尽可能减少Join 语句中的Nested Loop 的循环总次数，用小结果集驱动大结果集；</li>
<li>优先优化Nested Loop 的内层循环；</li>
<li>保证Join 语句中被驱动表上Join 条件字段已经被索引；</li>
<li>扩大join buffer的大小；</li>
</ol>
<h1 id="优化原则">优化原则<a hidden class="anchor" aria-hidden="true" href="#优化原则">#</a></h1>
<h2 id="原则一选择需要优化的sql">原则一：选择需要优化的SQL<a hidden class="anchor" aria-hidden="true" href="#原则一选择需要优化的sql">#</a></h2>
<ol>
<li>
<p>选择需要优化的SQL：</p>
<p>不是所有的SQL都需要优化，在优化的过程中，首选更需要优化的SQL；
怎么选择?优先选择优化高并发低消耗的SQL；</p>
<ol>
<li>1小时请求1W次，1次10个IO；</li>
<li>1小时请求10次，1次1W个IO；
考虑：</li>
<li>从单位时间产生的IO总数来说，相同的；</li>
<li>针对一个SQL，如果我能把10个IO变成7个IO，一小时减少3W个IO；
针对第二个SQL，如果能把1W个IO变成7K个IO，一小时减少3W个IO；</li>
<li>从优化难度上讲，1W-&gt;7K难的多；</li>
<li>从整体性能上来说，第一个SQL的优化能够极大的提升系统整体的性能；第二个SQL慢一点，无非也就是10个连接查询慢一点；</li>
</ol>
</li>
<li>
<p>定位性能瓶颈；</p>
<ol>
<li>SQL运行较慢有两个影响原因，IO和CPU，明确性能瓶颈所在；</li>
<li>明确优化目标；</li>
</ol>
</li>
</ol>
<h2 id="原则二从explain和profile入手">原则二：从Explain和Profile入手<a hidden class="anchor" aria-hidden="true" href="#原则二从explain和profile入手">#</a></h2>
<ol>
<li>任何SQL的优化，都从Explain语句开始；Explain语句能够得到数据库执行该SQL选择的执行计划；</li>
<li>首先明确需要的执行计划，再使用Explain检查；</li>
<li>使用profile明确SQL的问题和优化的结果；</li>
</ol>
<h2 id="原则三永远用小结果集驱动大的结果集">原则三：永远用小结果集驱动大的结果集<a hidden class="anchor" aria-hidden="true" href="#原则三永远用小结果集驱动大的结果集">#</a></h2>
<h2 id="原则四在索引中完成排序">原则四：在索引中完成排序<a hidden class="anchor" aria-hidden="true" href="#原则四在索引中完成排序">#</a></h2>
<h2 id="原则五使用最小columns">原则五：使用最小Columns<a hidden class="anchor" aria-hidden="true" href="#原则五使用最小columns">#</a></h2>
<ol>
<li>减少网络传输数据量；</li>
<li>特别是需要使用<code>column</code>排序的时候。<code>MySQL</code>排序原理，是把所有的<code>column</code>数据全部取出，在排序缓存区排序，再返回结果；如果<code>column</code>数据量大，排序区容量不够的时候，就会使用先<code>column</code>排序，再取数据，再返回的多次请求方式；</li>
</ol>
<h2 id="原则六使用最有效的过滤条件">原则六：使用最有效的过滤条件<a hidden class="anchor" aria-hidden="true" href="#原则六使用最有效的过滤条件">#</a></h2>
<ol>
<li>过多的<code>WHERE</code>条件不一定能够提高访问性能；</li>
<li>一定要让<code>WHERE</code>条件使用自己预期的执行计划；</li>
</ol>
<h2 id="原则七避免复杂的join和子查询">原则七：避免复杂的JOIN和子查询<a hidden class="anchor" aria-hidden="true" href="#原则七避免复杂的join和子查询">#</a></h2>
<ol>
<li>复杂的<code>JOIN</code>和子查询，需要锁定过多的资源，<code>MySQL</code>在大量并发情况下处理锁定性能下降较快；</li>
<li>不要过多依赖<code>SQL</code>的功能，把复杂的<code>SQL</code>拆分为简单的<code>SQL</code>；</li>
<li><code>MySQL</code>子查询性能较低，应尽量避免使用；</li>
</ol>
<h1 id="innodb_buffer和事务">innodb_buffer和事务<a hidden class="anchor" aria-hidden="true" href="#innodb_buffer和事务">#</a></h1>
<ol>
<li>
<p><code>Innodb_buffer_pool_size</code>：<code>innodb</code>的缓存，可以用于缓存索引，同时还会缓存实际的数据；
<code>innodb_buffer_pool_size</code> 参数用来设置<code>Innodb</code> 最主要的<code>Buffer</code>(<code>Innodb_Buffer_Pool</code>)的大小，对<code>Innodb</code> 整体性能影响也最大，可以按需要设置大一些；</p>
</li>
<li>
<p><code>innodb</code>中的事务处理：</p>
<ol>
<li>理解<code>Innodb</code>事务机制：
<ol>
<li>事务在<code>buffer</code>中对数据进行修改；</li>
<li>事务的变化记录在事务日志中；</li>
<li>在合适的时机同步事务日志中的数据到数据库中；</li>
</ol>
</li>
<li>所以什么时候提交事务日志文件，对系统性能影响较大，可以通过设置<code>innodb_flush_log_at_trx_commit</code>来修改事务日志同步时机：
<ol>
<li><code>innodb_flush_log_at_trx_commit = 0</code>，每1秒钟同步一次事务日志文件；</li>
<li><code>innodb_flush_log_at_trx_commit = 1</code>. 默认设置，每一个事务完成之后，同步一次事务日志文件；</li>
<li><code>innodb_flush_log_at_trx_commit = 2</code>. 事务完成之后，写到事务日志文件中，等到日志覆盖再同步数据；</li>
<li>注意，1性能最差，2不能完全保证数据是写到数据文件中，如果宕机，可能会有数据丢失现象，但性能最高；1性能和安全性居中；</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="主从架构">主从架构<a hidden class="anchor" aria-hidden="true" href="#主从架构">#</a></h1>
<p>简单理解下主从架构诞生的背景：
应用开发中常见的由量带来的问题：系统太卡！</p>
<ol>
<li>研发判断是<code>web</code>服务器的压力过大，此时我们可以增加<code>web</code>服务器的配置、数量，由单点增加量后借助负载均衡来分发流量，这样可以解决<code>web</code>服务器压力过大的问题。</li>
<li>如果还是卡，通过查看<code>MySQL</code>监控发现<code>QPS</code>上来了，单点数据库遇到瓶颈，可以考虑在应用层增加缓存层，此时<code>MySQL</code>单点压力被分发了，问题解决。</li>
<li>如果还是卡，并且已经实施了上述方案，分析应用使用<code>MySQL</code>的姿势，发现大多数请求都是查询。此时可以考虑主从架构，使用从节点分担主节点读的压力。</li>
</ol>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication.html"><code>MySQL</code>主从复制的文档</a>，默认复制操作是异步的，因此在<code>TPS</code>突刺时会有延迟的现象，具体优化可参见官方配置文档。</p>
<p>考虑到主从复制的延迟问题，研发在应用设计实现时需做提前考虑：</p>
<ol>
<li>所有写操作由主节点完成；</li>
<li>对读写一致性实时性要求高的业务需在应用层指定策略（一直读主、延迟读从）；</li>
<li>对读写一致性实时性要求不高的业务可以宽松处理；</li>
<li>事务需保证读写都在一个实例上；</li>
</ol>
<p>主从的大致流程：</p>
<p>主从同步的目的是要保证从节点与主节点一致的<code>DDL</code>/<code>DML</code>/<code>TCL</code>语句的执行状态，<code>MySQL</code>使用<code>binlog</code>记录变更。</p>
<ol>
<li>打开<code>binlog</code>，主节点记录所有<code>DDL</code>/<code>DML</code>/<code>TCL</code>语句；</li>
<li>主节点使用被动注册的方式联通主从节点，从节点主动请求主节点，这种方式下增删从节点对主节点无影响；</li>
<li>从节点起一个线程向主节点请求，询问某个点之后更新的数据；</li>
<li>主节点收到从节点请求，读取<code>binlog</code>，返回给从节点；</li>
<li>从节点获取响应之后将数据写入<code>relaylog</code>，<code>relaylog</code>记录主节点请求返回的变更；</li>
<li>从节点开启另外专用的线程处理<code>relaylog</code>；</li>
</ol>
<p>2024.02.27补充图例：
<img loading="lazy" src="mysql_master_slave_replication_diagram1.png" alt=""  />

<img loading="lazy" src="mysql_master_slave_replication_diagram2.png" alt=""  />
</p>
<h1 id="ref">Ref<a hidden class="anchor" aria-hidden="true" href="#ref">#</a></h1>
<ul>
<li><a href="https://developer.aliyun.com/article/945903">后端思维之数据库性能优化方案</a></li>
</ul>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://redolog.github.io/tags/mysql/">MySQL</a></li>
      <li><a href="https://redolog.github.io/tags/cheatsheet/">cheatsheet</a></li>
      <li><a href="https://redolog.github.io/tags/index/">index</a></li>
      <li><a href="https://redolog.github.io/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/">索引优化</a></li>
      <li><a href="https://redolog.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://redolog.github.io/posts/rd/algo/oj/leetcode/linked-list-cycle-ii/">
    <span class="title">« Prev Page</span>
    <br>
    <span>LeetCode 142. 环形链表 II 题解</span>
  </a>
  <a class="next" href="https://redolog.github.io/posts/rd/design/pattern/index/">
    <span class="title">Next Page »</span>
    <br>
    <span>设计模式一览</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL性能优化cheatsheet on twitter"
        href="https://twitter.com/intent/tweet/?text=MySQL%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96cheatsheet&amp;url=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fstorage%2fmysql%2fperformance-optimization%2fcheatsheet%2f&amp;hashtags=MySQL%2ccheatsheet%2cindex%2c%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%2c%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL性能优化cheatsheet on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fstorage%2fmysql%2fperformance-optimization%2fcheatsheet%2f&amp;title=MySQL%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96cheatsheet&amp;summary=MySQL%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96cheatsheet&amp;source=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fstorage%2fmysql%2fperformance-optimization%2fcheatsheet%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL性能优化cheatsheet on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fstorage%2fmysql%2fperformance-optimization%2fcheatsheet%2f&title=MySQL%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96cheatsheet">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL性能优化cheatsheet on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fstorage%2fmysql%2fperformance-optimization%2fcheatsheet%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL性能优化cheatsheet on whatsapp"
        href="https://api.whatsapp.com/send?text=MySQL%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96cheatsheet%20-%20https%3a%2f%2fredolog.github.io%2fposts%2frd%2fstorage%2fmysql%2fperformance-optimization%2fcheatsheet%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share MySQL性能优化cheatsheet on telegram"
        href="https://telegram.me/share/url?text=MySQL%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96cheatsheet&amp;url=https%3a%2f%2fredolog.github.io%2fposts%2frd%2fstorage%2fmysql%2fperformance-optimization%2fcheatsheet%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
      const gitalk = new Gitalk({
            clientID: 'bc5a91c74dda1fd92a10',
            clientSecret: '99a821a1c27e5dc85ea3105bf9bba089d1b580ea',
            repo: 'blog-comment',
            owner: 'redolog',
            admin: ['redolog'],
            id: md5(location.pathname), 
            distractionFreeMode: false 
      });
      (function () {
            if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
                  document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
                  return;
            }
            gitalk.render('gitalk-container');
      })();
</script>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://redolog.github.io/">宋惠龙的博客</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
